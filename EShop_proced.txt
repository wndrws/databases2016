/*
1. Вычислить максимально позднюю дату поставки заданного товара на основании текущих
остаков на складах и скорости продажи.
2. Для заданного товара произвести поиск аналогов с аналогичными или лучшими характеристиками.
В выводе списка аналогов выводить их средний рейтинг по отзывам.
*/

SET TERM ^;

CREATE EXCEPTION ex_TooNewArticle
'Нельзя рассчитать максимально позднюю дату поставки этого товара - сегодня он поступил впервые!'^

CREATE EXCEPTION ex_NoSells
'На данный момент не продано ни одной единицы этого товара!'^

CREATE EXCEPTION ex_NoArrivals
'Данный товар не поступал ни на один склад!'^

CREATE PROCEDURE dateToNextArrival (targetArticle TYPE OF COLUMN goods.Article)
RETURNS (dateTNA DATE) AS
	DECLARE VARIABLE sellRate FLOAT;
	DECLARE VARIABLE firstArrivalDate DATE;
	DECLARE VARIABLE totalSells INTEGER;
	DECLARE VARIABLE remains INTEGER;
BEGIN
	-- Найдем самую раннюю дату поставки целевого товара
	SELECT Arr_Date FROM arrivals WHERE article = :targetArticle
	ORDER BY Arr_Date ASC ROWS 1 INTO :firstArrivalDate;
	IF (firstArrivalDate IS NULL) THEN EXCEPTION ex_NoArrivals;
	-- Определим общее кличество проданных единиц целевого товара
	SELECT SUM(od.Quantity) FROM orders_distribution od NATURAL JOIN orders o
	WHERE od.article = :targetArticle AND o.Status = 3 INTO :totalSells;
	-- Не делаем проверку на o.Order_Date >= :firstArrivalDate, т.к. предзаказы тоже идут в зачет
	IF (firstArrivalDate = 'TODAY') THEN EXCEPTION ex_TooNewArticle;
	IF (totalSells IS NULL OR totalSells = 0) THEN EXCEPTION ex_NoSells;
	-- Вычислим среднюю скорость продажи товара в шт./день
	sellRate = totalSells/CAST((date 'TODAY' - firstArrivalDate) AS FLOAT);
	-- Выясним, сколько единиц целевого товара осталось на складах
	SELECT SUM(Quantity) FROM availability WHERE article = :targetArticle INTO :remains;
	-- Теперь можем найти максимально позднюю дату поставки заданного товара 
	dateTNA = date 'TODAY' + CAST(remains/sellRate AS INTEGER);
END^

CREATE PROCEDURE findAnalogues
(sourceArticle TYPE OF COLUMN goods.Article, compSpecID TYPE OF COLUMN specifications.ID)
RETURNS
(resArticle TYPE OF COLUMN goods.Article, resName TYPE OF COLUMN goods.Name, avgRating NUMERIC(3,2))
AS
	DECLARE VARIABLE sourceSpecVal TYPE OF COLUMN spec_arrangement.Spec_value;
	DECLARE VARIABLE curArticle TYPE OF COLUMN goods.Article;
	DECLARE VARIABLE curSpecID TYPE OF COLUMN specifications.ID;
	DECLARE VARIABLE curSpecVal TYPE OF COLUMN spec_arrangement.Spec_value;
	DECLARE VARIABLE compRes SMALLINT;
BEGIN
	-- Определяем значение характеристики исходного товара
	SELECT Spec_value FROM spec_arrangement WHERE article = :sourceArticle AND specID = :compSpecID
	INTO :sourceSpecVal;
	-- Ищем товары с лучшими или такими же значениями данной характеристики
	FOR SELECT article, specID, Spec_value FROM spec_arrangement
	WHERE article <> :sourceArticle AND specID = :compSpecID
	INTO :curArticle, :curSpecID, :curSpecVal DO BEGIN
		EXECUTE PROCEDURE isSameOrBetter(sourceSpecVal, curSpecVal, curSpecID)
			RETURNING_VALUES :compRes;
		IF(compRes IN (1, 2)) THEN BEGIN
			resArticle = curArticle;
			resName = (SELECT Name FROM goods WHERE Article = :curArticle);
			avgRating = (SELECT AVG(CAST(Rating AS NUMERIC(3,2))) FROM reviews WHERE article = :curArticle);
			SUSPEND;
		END
	END
END^

/* Данная процедура сравнивает два значения характеристик типа specType и возвращает:
	2, если они совпадают;
	1, если значение RHS лучше, чем LHS;
	0, если значения не совпадают, и нельзя сказать, что одно из них лучше другого. */
CREATE PROCEDURE isSameOrBetter(LHS TYPE OF COLUMN spec_arrangement.Spec_value,
						  RHS TYPE OF COLUMN spec_arrangement.Spec_value,
						  specType TYPE OF COLUMN specifications.ID)
RETURNS (res SMALLINT) AS
BEGIN
	IF(specType IN (1, 3, 4, 5)) THEN 
	-- Целочисленные значения, для которых больше значит лучше
		IF(CAST(LHS AS INTEGER) < CAST(RHS AS INTEGER)) 
			THEN res = 1; 
			ELSE IF(LHS = RHS) THEN res = 2; ELSE res = 0;
	ELSE IF(specType = 2) THEN
	-- Значения, на основе которых нельзя сказать, какой из двух товаров лучше
		IF(LHS = RHS) THEN res = 2; ELSE res = 0;
	ELSE res = 0;
END^

SET TERM ;^

-- Пример вызова
SELECT resArticle AS "Артикул", resName AS "Наименование", avgRating AS "Средний рейтинг"
FROM findAnalogues(10, 1) ORDER BY avgRating DESC;

/*

CREATE PROCEDURE testTypes RETURNS (res INTEGER) AS
BEGIN
	FOR SELECT Article FROM GOODS INTO :res DO SUSPEND;
	--:res = 1234/(date 'TODAY' - date '12.12.2016');
END^

*/